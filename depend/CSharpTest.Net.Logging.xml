<?xml version="1.0" encoding="utf-8"?>
<doc>
    <assembly>
        <name>CSharpTest.Net.Logging</name>
    </assembly>
    <members>
        <member name="T:CSharpTest.Net.Utils.ProcessInfo">
            <summary>
            Utility class for obtaining information about the currently running
            process and AppDomain
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.UNKNOWN">
            <summary> Returns the string '[Unknown]'</summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.ProcessId">
            <summary> Returns the current process id </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.ProcessName">
            <summary> Returns the current process name without an extension </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.ProcessFile">
            <summary> Returns the file path to the exe for this process </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.AppDomainName">
            <summary> Returns the current AppDomain's friendly name </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.EntryAssembly">
            <summary> Returns the entry-point assembly or the highest stack assembly </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.ProductVersion">
            <summary> Returns the product version of the entry assembly </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.ProductName">
            <summary> Returns the product name of the entry assembly </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.CompanyName">
            <summary> Returns the company name of the entry assembly </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.IsDebugging">
            <summary> Returns true if a debugger is attached to the process </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.RegistrySoftwarePath">
            <summary>
            Returns the HKCU or HKLM path for this software application based
            on the process that is running: Software\{CompanyName}\{ProductName}
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.ApplicationData">
            <summary>
            Returns the roaming user profile path for the currently running software
            application: {SpecialFolder.ApplicationData}\{CompanyName}\{ProductName}
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.LocalApplicationData">
            <summary>
            Returns the non-roaming user profile path for the currently running software
            application: {SpecialFolder.LocalApplicationData}\{CompanyName}\{ProductName}
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Utils.ProcessInfo.DefaultLogFile">
            <summary>
            Returns a default log file name derived as:
            {SpecialFolder.LocalApplicationData}\{CompanyName}\{ProductName}\{AppDomainName}.txt
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Utils.ProcessInfo.#ctor">
            <summary>
            This is some ugly code, the intent is to be able to answer the above questions in 
            a wide array of environments.  I admit now this may fail eventually.
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Utils.ProcessInfo.SafeName(System.String)">
            <summary>
            Copy from StringUtils
            </summary>
        </member>
        <member name="T:CSharpTest.Net.Logging.Implementation.MessageQueue">
            <summary>
            NOTE TO READER:
            
            I will appologize up front for this library.  I don't normally condone this type of proceedural
            and repetitive coding.  This is ONLY being done in this library to reduce the temporal cost of
            using it.  
            In a nutshell: this being easy to maintain is not as important as library performance.
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.MessageQueue.ListenerSync">
            <summary> This allows for async subscriptions to InternalLogWrite event </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.MessageQueue.__eventCounter">
            <summary> Keeps a running counter of events and assigns a unique one to each log entry</summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.MessageQueue._logFile">
            <summary> If logging configured to disk, we manage the currently open log file here</summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.MessageQueue.LogFileSync">
            <summary> Used to syncronize access to log file while writting log entries and changing the log file</summary>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.MessageQueue.WorkerThreadProc">
            <summary>
            This thread proc manages the pumping of messages to the listeners, this is
            ONLY available when StartThreading() has been called via constructor of a
            ThreadingControl() object, (client calls Log.AppStart( name ))
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.MessageQueue.StartThreading">
            <summary>
            This is NOT thread safe, locking is done through ThreadingControl
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.MessageQueue.StopThreading">
            <summary>
            This is NOT thread safe, locking is done through ThreadingControl
            </summary>
        </member>
        <member name="E:CSharpTest.Net.Logging.Implementation.MessageQueue.InternalLogWrite">
            <summary> This is the actual event list we will dispatch to when logs are written </summary>
        </member>
        <member name="T:CSharpTest.Net.Logging.Implementation.SharedException">
            <summary>
            Exceptions of any kind are turned into this when serialized to another process... This is intentional to prevent issues
            of crossing .Net versions as well as simple client coding mistakes (Non-Serializable Exceptions).
            </summary>
        </member>
        <member name="T:CSharpTest.Net.Logging.Implementation.VersionInfo">
            <summary>
            This is a small utility class for computing a hash of the fields to prevent different versions from
            having issues durring de-serialization.
            </summary>
        </member>
        <member name="T:CSharpTest.Net.Logging.LogLevels">
            <summary>
            Defines the various levels of logging
            </summary>
        <seealso cref="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)" cat="Used By">LogLevels Log.Config.SetOutputLevel(LogOutputs,LogLevels)</seealso><seealso cref="P:Log.Config.Level">LogLevels Log.Config.Level</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ConfigTest.cs#277">Log/Test/ConfigTest.cs</see></para><code lang="C#">            LogOutputs output = Log.Config.Output;
            try
            {
                string messageText = "Warning will robinson, DANGER!";

                Log.Config.SetOutputFormat(LogOutputs.All, "{Message}");
                Log.Config.SetOutputLevel(LogOutputs.All, LogLevels.Info);

                LogLevels newLevel = LogLevels.Warning;
                Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.AspNetTrace, newLevel));
                Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.TraceWrite, newLevel));
                Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.Console, newLevel));
                Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.EventLog, newLevel));
                Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.LogFile, newLevel));
                Assert.AreEqual(LogLevels.None, Log.Config.SetOutputLevel(LogOutputs.None, newLevel));

                Log.Config.Output = LogOutputs.All &amp; ~LogOutputs.EventLog;

                TextWriter sw = new StringWriter(), orig = Console.Out;
                Console.SetOut(sw);
                string tempFile = Path.GetTempFileName();
                string origLog = Log.Config.LogFile;
                Log.Config.LogFile = tempFile;
                try
                {
                    Log.Warning(messageText);
                    Log.Info("Hello");
                    Log.Verbose("Hello");
                }
                finally
                {
                    Console.SetOut(orig);
                    Log.Config.LogFile = origLog;
                }

                Assert.AreEqual(messageText, _lastTrace.Substring(GetType().FullName.Length + 2));
                Assert.AreEqual(messageText, sw.ToString().Trim());
                Assert.AreEqual(messageText, File.ReadAllText(tempFile).Trim());
            }
            finally
            {
                Log.Config.Output = output;
                Log.Config.SetOutputLevel(LogOutputs.All, LogLevels.Verbose);
                Log.Config.SetOutputFormat(LogOutputs.All, "[{ManagedThreadId}] {Level} - {FullMessage}");
            }</code><code lang="VB.NET">        Dim output As LogOutputs = Log.Config.Output
        Try
            Dim messageText As String = "Warning will robinson, DANGER!"

            Log.Config.SetOutputFormat(LogOutputs.All, "{Message}")
            Log.Config.SetOutputLevel(LogOutputs.All, LogLevels.Info)

            Dim newLevel As LogLevels = LogLevels.Warning
            Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.AspNetTrace, newLevel))
            Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.TraceWrite, newLevel))
            Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.Console, newLevel))
            Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.EventLog, newLevel))
            Assert.AreEqual(LogLevels.Info, Log.Config.SetOutputLevel(LogOutputs.LogFile, newLevel))
            Assert.AreEqual(LogLevels.None, Log.Config.SetOutputLevel(LogOutputs.None, newLevel))

            Log.Config.Output = LogOutputs.All And Not LogOutputs.EventLog

            Dim sw As TextWriter = New StringWriter(), orig As TextWriter = Console.Out
            Console.SetOut(sw)
            Dim tempFile As String = Path.GetTempFileName()
            Dim origLog As String = Log.Config.LogFile
            Log.Config.LogFile = tempFile
            Try
                Log.Warning(messageText)
                Log.Info("Hello")
                Log.Verbose("Hello")
            Finally
                Console.SetOut(orig)
                Log.Config.LogFile = origLog
            End Try

            Assert.AreEqual(messageText, _lastTrace.Substring([GetType]().FullName.Length + 2))
            Assert.AreEqual(messageText, sw.ToString().Trim())
            Assert.AreEqual(messageText, File.ReadAllText(tempFile).Trim())
        Finally
            Log.Config.Output = output
            Log.Config.SetOutputLevel(LogOutputs.All, LogLevels.Verbose)
            Log.Config.SetOutputFormat(LogOutputs.All, "[{ManagedThreadId}] {Level} - {FullMessage}")
        End Try</code></example></member>
        <member name="F:CSharpTest.Net.Logging.LogLevels.None">
            <summary> Logging is disabled </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogLevels.Critical">
            <summary> Logs a Fatal error </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogLevels.Error">
            <summary> Logs an Error </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogLevels.Warning">
            <summary> Logs a Warning </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogLevels.Info">
            <summary> Logs an Informational message </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogLevels.Verbose">
            <summary> Logs a Verbose message </summary>
        </member>
        <member name="T:CSharpTest.Net.Logging.LogOutputs">
            <summary>
            Defines the various possble outputs of the logging system
            </summary>
        <seealso cref="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)" cat="Used By">LogLevels Log.Config.SetOutputLevel(LogOutputs,LogLevels)</seealso><seealso cref="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)" cat="Used By">Log.Config.SetOutputFormat(LogOutputs,String)</seealso><seealso cref="P:Log.Config.Output">LogOutputs Log.Config.Output</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ConfigTest.cs#66">Log/Test/ConfigTest.cs</see></para><code lang="C#">            LogOutputs defaultOutputs = Log.Config.Output;
            Assert.AreEqual(defaultOutputs, Log.Config.Output);
            Log.Config.Output = LogOutputs.TraceWrite;

            Log.Write("Test Trace");
            Assert.AreEqual(GetType().FullName + ": Test Trace", _lastTrace);

            Assert.AreEqual(LogOutputs.TraceWrite, Log.Config.Output);

            Log.Config.Output = LogOutputs.None;
            _lastTrace = null;
            Log.Write("Test Trace");
            Assert.IsNull(_lastTrace);

            Log.Config.Output = LogOutputs.TraceWrite | defaultOutputs;
            Assert.AreEqual(LogOutputs.TraceWrite | defaultOutputs, Log.Config.Output);</code><code lang="VB.NET">        Dim defaultOutputs As LogOutputs = Log.Config.Output
        Assert.AreEqual(defaultOutputs, Log.Config.Output)
        Log.Config.Output = LogOutputs.TraceWrite

        Log.Write("Test Trace")
        Assert.AreEqual([GetType]().FullName + ": Test Trace", _lastTrace)

        Assert.AreEqual(LogOutputs.TraceWrite, Log.Config.Output)

        Log.Config.Output = LogOutputs.None
        _lastTrace = Nothing
        Log.Write("Test Trace")
        Assert.IsNull(_lastTrace)

        Log.Config.Output = LogOutputs.TraceWrite Or defaultOutputs
        Assert.AreEqual(LogOutputs.TraceWrite Or defaultOutputs, Log.Config.Output)</code></example></member>
        <member name="F:CSharpTest.Net.Logging.LogOutputs.None">
            <summary> No default destination (Event will still fire if anyone is subscribed) </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOutputs.TraceWrite">
            <summary> Outputs messages to the System.Diagnostics.Trace.WriteLine() method </summary>
            <remarks> Note: Always on by default when System.Diagnostics.Debugger.IsAttached == true </remarks>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOutputs.LogFile">
            <summary> Outputs messages to this process' log file </summary>
            <remarks> Note: Always on by default to \Users\{Current}\AppData\Local\{Process Name}\{Process File Name}.log </remarks>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOutputs.Console">
            <summary> Outputs messages to the Console.[Out/Error].WriteLine() methods </summary>
            <remarks> Note: Always on by default when running as a console application </remarks>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOutputs.AspNetTrace">
            <summary> Outputs messages to the System.Web.HttpContext.Current.Trace.[Write/Warn]() methods </summary>
            <remarks> Note: Always on by default when /configuration/system.web/trace/@enabled == true </remarks>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOutputs.EventLog">
            <summary> Outputs messages to the event log </summary>
            <remarks> Note: Always on by default for Critical errors only </remarks>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOutputs.All">
            <summary> Writes to all LogOutput types available </summary>
        </member>
        <member name="T:CSharpTest.Net.Logging.LogOptions">
            <summary>
            Performance and behavior related LogOption for the log system.
            </summary>
        <seealso cref="P:Log.Config.Options">LogOptions Log.Config.Options</seealso></member>
        <member name="F:CSharpTest.Net.Logging.LogOptions.Default">
            <summary>
            These are the default options used.  Addtionally, if your debugging or using asp.net trace,
            the following will also be set: LogAddFileInfo
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOptions.None">
            <summary>
            No LogOption enabled
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOptions.LogImmediateCaller">
            <summary>
            Calls new StackFrame( n ) to retrieve the immediate caller of the log routine and pass 
            it along to all logging information.
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOptions.LogNearestCaller">
            <summary>
            Starting with n frames back walk back until the calling class is not decorated with the
            ////[System.Diagnostics.DebuggerNonUserCode()] attribute.  This allows you to create wrapper
            classes that provide logging but are not considered to be the point of origin in the log.
            Can be slightly slower as this now reflects each class' attributes and addtionally may 
            gather more than one stack frame.
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOptions.LogAddFileInfo">
            <summary>
            If this is specified the file and line number where the log call was made will be available
            to log LogOutput.
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOptions.ConsoleColors">
            <summary>
            Uses a different color based on the level of the log message, Use ONLY nothing else is
            writting to the console.
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOptions.LogAddAssemblyInfo">
            <summary>
            Populate the MethodAssemblyVersion and MethodAssembly properties for logging. Requires
            at least the LogImmediateCaller information.
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogOptions.GZipLogFileOnRoll">
            <summary>
            GZip and append a .gz extension to log files as they are rolled, the current log file
            will remain unzipped.
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FILE_SIZE_THREASHOLD">
            <summary> This is the max size a file will get (roughly) before being renamed </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FILE_MAX_HISTORY_SIZE">
            <summary> This is the max number of files to keep, don't set too high until you revisit RollingRenameFile()</summary>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.Configuration.#cctor">
            <summary> Initializes all readonly configuration values </summary>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.Configuration.Configure">
            <summary> Sets appropriate (i hope) defaults to all configuration options </summary>
        </member>
        <member name="T:Log">
            <summary>
            Provides an abstraction api for logging to various outputs.  This class in the global namespace for a reason.
            Since you may want to change log infrastructure at any time, it's important that no 'Using' statements are
            required to access the log infrastructure.  Secondly, a static class api can provide improved performance
            over other possible types.  We will be forcing the default configuration of log4net rather than requiring
            each component to independently configure itself.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="M:Log.AppStart(System.String,System.Object[])">
            <summary> 
            Enables calls to Log.xxx() to be processed on another thread to improve throughput... 
            Place this in a using() statement within Main:  using( new Log.AppStart("Some Name") )
            This call (and Disponse) IS Thread safe and can be called multiple times either 
            concurrently, sequentially, nested, or overlapping calls are all permitted and handled.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#212" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Start(System.String,System.Object[])">
            <summary>
            Pushes a string into the trace stack so that log messages appear with the 'context'
            set to the information provided.  The operation named should be performed by the
            current thread and the IDisposable object returned should be disposed when the
            operation completes.
            </summary>
            
            <param name="format"></param>
            <param name="args"></param>
            <returns>An IDisposable object that should be destroyed by calling the Dispose() 
            method when the activity is complete.</returns>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#230" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ThreadedLogTest.cs#50">Log/Test/ThreadedLogTest.cs</see></para><code lang="C#">            Log.LogWrite += new LogEventHandler(Block_LogWrite);
            try
            {
                using (Log.Start("Blocking Test"))
                {
                    //the start above should already get us in a blocked state:
                    Assert.IsTrue(_isBlocked.WaitOne(300, false));

                    //regaurdless, we should still get the first message
                    EventData msg = NextMessage;
                    Assert.AreEqual("Start Blocking Test", msg.Message);

                    //Now let's just go nuts on the logger...
                    for (int i = 0; i &lt; 100; i++)
                        Log.Write("Buffering at {0}%.", i);

                    Thread.Sleep(100);
                    Assert.AreEqual(0, _lastMessages.Count);
                    _releaseBlock.Set();
                    Thread.Sleep(100);
                    Assert.IsFalse(_isBlocked.WaitOne(0, false));

                    for (int i = 0; i &lt; 100; i++)
                        Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"));
                }
            }
            finally
            {
                Log.LogWrite -= new LogEventHandler(Block_LogWrite);
            }</code><code lang="VB.NET">        Log.LogWrite += New LogEventHandler(Block_LogWrite)
        Try
            Using Log.Start("Blocking Test")
                'the start above should already get us in a blocked state:
                Assert.IsTrue(_isBlocked.WaitOne(300, False))

                'regaurdless, we should still get the first message
                Dim msg As EventData = NextMessage
                Assert.AreEqual("Start Blocking Test", msg.Message)

                'Now let's just go nuts on the logger...
                Dim i As Integer = 0
                While i &lt; 100
                    Log.Write("Buffering at {0}%.", i)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Thread.Sleep(100)
                Assert.AreEqual(0, _lastMessages.Count)
                _releaseBlock.[Set]()
                Thread.Sleep(100)
                Assert.IsFalse(_isBlocked.WaitOne(0, False))

                Dim i As Integer = 0
                While i &lt; 100
                    Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
            End Using
        Finally
            Log.LogWrite -= New LogEventHandler(Block_LogWrite)
        End Try</code></example></member>
        <member name="M:Log.ClearStack">
            <summary>
            Forces any left-behind calls to Start() to be closed.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#235" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/BasicLogTest.cs#276">Log/Test/BasicLogTest.cs</see></para><code lang="C#">            Log.Write(UniqueData);
            EventData msg = LastMessage;
            Assert.IsNull(msg.LogCurrent);
            Assert.IsNull(msg.LogStack);

            using (Log.Start(UniqueData))
            {
                msg = LastMessage;
                Assert.AreEqual("Start " + UniqueData, msg.Message);
                Assert.AreEqual(UniqueData, msg.LogCurrent);
                Assert.AreEqual(msg.LogCurrent, msg.LogStack);

                Log.ClearStack();
                Log.Warning("Stack cleared");
                msg = LastMessage;
                Assert.IsNull(msg.LogCurrent);
                Assert.IsNull(msg.LogStack);
            }

            //no message generated.
            Assert.AreEqual(0, _lastMessages.Count);
            Assert.IsNull(msg.LogCurrent);
            Assert.IsNull(msg.LogStack);</code><code lang="VB.NET">        Log.Write(UniqueData)
        Dim msg As EventData = LastMessage
        Assert.IsNull(msg.LogCurrent)
        Assert.IsNull(msg.LogStack)

        Using Log.Start(UniqueData)
            msg = LastMessage
            Assert.AreEqual("Start " + UniqueData, msg.Message)
            Assert.AreEqual(UniqueData, msg.LogCurrent)
            Assert.AreEqual(msg.LogCurrent, msg.LogStack)

            Log.ClearStack()
            Log.Warning("Stack cleared")
            msg = LastMessage
            Assert.IsNull(msg.LogCurrent)
            Assert.IsNull(msg.LogStack)
        End Using

        'no message generated.
        Assert.AreEqual(0, _lastMessages.Count)
        Assert.IsNull(msg.LogCurrent)
        Assert.IsNull(msg.LogStack)</code></example></member>
        <member name="M:Log.Write(System.String,System.Object[])">
            <summary>
            Write directly to the log reguardless of the currently configured log-LogLevel
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#241" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ThreadedLogTest.cs#50">Log/Test/ThreadedLogTest.cs</see></para><code lang="C#">            Log.LogWrite += new LogEventHandler(Block_LogWrite);
            try
            {
                using (Log.Start("Blocking Test"))
                {
                    //the start above should already get us in a blocked state:
                    Assert.IsTrue(_isBlocked.WaitOne(300, false));

                    //regaurdless, we should still get the first message
                    EventData msg = NextMessage;
                    Assert.AreEqual("Start Blocking Test", msg.Message);

                    //Now let's just go nuts on the logger...
                    for (int i = 0; i &lt; 100; i++)
                        Log.Write("Buffering at {0}%.", i);

                    Thread.Sleep(100);
                    Assert.AreEqual(0, _lastMessages.Count);
                    _releaseBlock.Set();
                    Thread.Sleep(100);
                    Assert.IsFalse(_isBlocked.WaitOne(0, false));

                    for (int i = 0; i &lt; 100; i++)
                        Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"));
                }
            }
            finally
            {
                Log.LogWrite -= new LogEventHandler(Block_LogWrite);
            }</code><code lang="VB.NET">        Log.LogWrite += New LogEventHandler(Block_LogWrite)
        Try
            Using Log.Start("Blocking Test")
                'the start above should already get us in a blocked state:
                Assert.IsTrue(_isBlocked.WaitOne(300, False))

                'regaurdless, we should still get the first message
                Dim msg As EventData = NextMessage
                Assert.AreEqual("Start Blocking Test", msg.Message)

                'Now let's just go nuts on the logger...
                Dim i As Integer = 0
                While i &lt; 100
                    Log.Write("Buffering at {0}%.", i)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Thread.Sleep(100)
                Assert.AreEqual(0, _lastMessages.Count)
                _releaseBlock.[Set]()
                Thread.Sleep(100)
                Assert.IsFalse(_isBlocked.WaitOne(0, False))

                Dim i As Integer = 0
                While i &lt; 100
                    Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
            End Using
        Finally
            Log.LogWrite -= New LogEventHandler(Block_LogWrite)
        End Try</code></example></member>
        <member name="M:Log.Critical(System.Exception)">
            <summary> Logs a Critical error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#245" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Critical(System.Exception,System.String,System.Object[])">
            <summary> Logs a Critical error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#248" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Critical(System.String,System.Object[])">
            <summary> Logs a Critical error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#251" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Error(System.Exception)">
            <summary> Logs an Error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#255" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Error(System.Exception,System.String,System.Object[])">
            <summary> Logs an Error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#258" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="M:Log.Error(System.String,System.Object[])">
            <summary> Logs an Error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#261" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Warning(System.Exception)">
            <summary> Logs a Warning </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#265" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Warning(System.Exception,System.String,System.Object[])">
            <summary> Logs a Warning </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#268" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Warning(System.String,System.Object[])">
            <summary> Logs a Warning </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#271" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Info(System.Exception)">
            <summary> Logs a Info error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#275" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Info(System.Exception,System.String,System.Object[])">
            <summary> Logs a Info error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#278" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Info(System.String,System.Object[])">
            <summary> Logs an Informational message </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#281" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Verbose(System.Exception)">
            <summary> Logs a Verbose error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#285" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Verbose(System.Exception,System.String,System.Object[])">
            <summary> Logs a Verbose error </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#288" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="M:Log.Verbose(System.String,System.Object[])">
            <summary> Logs a Verbose message </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#291" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#68">Log/Test/NegativeTests.cs</see></para><code lang="C#">            IDisposable disp = Log.AppStart(null);
            disp.Dispose();
            disp.Dispose();
            foreach( string format in badFormats )
                Log.AppStart(format, i_blow_up).Dispose();

            disp = Log.Start(null);
            disp.Dispose();
            disp.Dispose();
            foreach (string format in badFormats)
                Log.AppStart(format, i_blow_up).Dispose();

            foreach (string format in badFormats)
                Log.Write(format, i_blow_up);

            foreach (string format in badFormats)
                Log.Critical(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Critical(i_blow_up, format, i_blow_up);
            Log.Critical(i_blow_up);

            foreach (string format in badFormats)
                Log.Error(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Error(i_blow_up, format, i_blow_up);
            Log.Error(i_blow_up);

            foreach (string format in badFormats)
                Log.Warning(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Warning(i_blow_up, format, i_blow_up);
            Log.Warning(i_blow_up);

            foreach (string format in badFormats)
                Log.Info(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Info(i_blow_up, format, i_blow_up);
            Log.Info(i_blow_up);

            foreach (string format in badFormats)
                Log.Verbose(format, i_blow_up);
            foreach (string format in badFormats)
                Log.Verbose(i_blow_up, format, i_blow_up);
            Log.Verbose(i_blow_up);</code><code lang="VB.NET">        Dim disp As IDisposable = Log.AppStart(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        disp = Log.Start(Nothing)
        disp.Dispose()
        disp.Dispose()
        For Each format As String In badFormats
            Log.AppStart(format, i_blow_up).Dispose()
        Next

        For Each format As String In badFormats
            Log.Write(format, i_blow_up)
        Next

        For Each format As String In badFormats
            Log.Critical(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Critical(i_blow_up, format, i_blow_up)
        Next
        Log.Critical(i_blow_up)

        For Each format As String In badFormats
            Log.[Error](format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.[Error](i_blow_up, format, i_blow_up)
        Next
        Log.[Error](i_blow_up)

        For Each format As String In badFormats
            Log.Warning(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Warning(i_blow_up, format, i_blow_up)
        Next
        Log.Warning(i_blow_up)

        For Each format As String In badFormats
            Log.Info(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Info(i_blow_up, format, i_blow_up)
        Next
        Log.Info(i_blow_up)

        For Each format As String In badFormats
            Log.Verbose(format, i_blow_up)
        Next
        For Each format As String In badFormats
            Log.Verbose(i_blow_up, format, i_blow_up)
        Next
        Log.Verbose(i_blow_up)</code></example></member>
        <member name="P:Log.IsInfoEnabled">
            <summary> Returns true if 'Info' messages are being recorded. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/BasicLogTest.cs#345">Log/Test/BasicLogTest.cs</see></para><code lang="C#">            Log.Config.Level = LogLevels.None;
            NextMessage.ToString();
            Assert.IsFalse(Log.IsVerboseEnabled);
            Assert.IsFalse(Log.IsInfoEnabled);

            _lastTrace = null;
            _lastMessages.Clear();

            Log.Critical("Test All off");
            Assert.IsNull(_lastTrace);
            Assert.AreEqual(0, _lastMessages.Count);

            Log.Write("Test PassThrough?");
            EventData data = LastMessage;
            Assert.AreEqual("Test PassThrough?", data.Message);</code><code lang="VB.NET">        Log.Config.Level = LogLevels.None
        NextMessage.ToString()
        Assert.IsFalse(Log.IsVerboseEnabled)
        Assert.IsFalse(Log.IsInfoEnabled)

        _lastTrace = Nothing
        _lastMessages.Clear()

        Log.Critical("Test All off")
        Assert.IsNull(_lastTrace)
        Assert.AreEqual(0, _lastMessages.Count)

        Log.Write("Test PassThrough?")
        Dim data As EventData = LastMessage
        Assert.AreEqual("Test PassThrough?", data.Message)</code></example></member>
        <member name="P:Log.IsVerboseEnabled">
            <summary> Returns true if 'Verbose' messages are being recorded. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/BasicLogTest.cs#345">Log/Test/BasicLogTest.cs</see></para><code lang="C#">            Log.Config.Level = LogLevels.None;
            NextMessage.ToString();
            Assert.IsFalse(Log.IsVerboseEnabled);
            Assert.IsFalse(Log.IsInfoEnabled);

            _lastTrace = null;
            _lastMessages.Clear();

            Log.Critical("Test All off");
            Assert.IsNull(_lastTrace);
            Assert.AreEqual(0, _lastMessages.Count);

            Log.Write("Test PassThrough?");
            EventData data = LastMessage;
            Assert.AreEqual("Test PassThrough?", data.Message);</code><code lang="VB.NET">        Log.Config.Level = LogLevels.None
        NextMessage.ToString()
        Assert.IsFalse(Log.IsVerboseEnabled)
        Assert.IsFalse(Log.IsInfoEnabled)

        _lastTrace = Nothing
        _lastMessages.Clear()

        Log.Critical("Test All off")
        Assert.IsNull(_lastTrace)
        Assert.AreEqual(0, _lastMessages.Count)

        Log.Write("Test PassThrough?")
        Dim data As EventData = LastMessage
        Assert.AreEqual("Test PassThrough?", data.Message)</code></example></member>
        <member name="E:Log.LogWrite">
            <summary>
            This event is raised when the logging routines are called and the LogLevel is at or
            higher than the current Log.LogLevels field value.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.Event.cs#28" cat="Source Code">Log/Log.Event.cs</seealso><seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ThreadedLogTest.cs#50">Log/Test/ThreadedLogTest.cs</see></para><code lang="C#">            Log.LogWrite += new LogEventHandler(Block_LogWrite);
            try
            {
                using (Log.Start("Blocking Test"))
                {
                    //the start above should already get us in a blocked state:
                    Assert.IsTrue(_isBlocked.WaitOne(300, false));

                    //regaurdless, we should still get the first message
                    EventData msg = NextMessage;
                    Assert.AreEqual("Start Blocking Test", msg.Message);

                    //Now let's just go nuts on the logger...
                    for (int i = 0; i &lt; 100; i++)
                        Log.Write("Buffering at {0}%.", i);

                    Thread.Sleep(100);
                    Assert.AreEqual(0, _lastMessages.Count);
                    _releaseBlock.Set();
                    Thread.Sleep(100);
                    Assert.IsFalse(_isBlocked.WaitOne(0, false));

                    for (int i = 0; i &lt; 100; i++)
                        Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"));
                }
            }
            finally
            {
                Log.LogWrite -= new LogEventHandler(Block_LogWrite);
            }</code><code lang="VB.NET">        Log.LogWrite += New LogEventHandler(Block_LogWrite)
        Try
            Using Log.Start("Blocking Test")
                'the start above should already get us in a blocked state:
                Assert.IsTrue(_isBlocked.WaitOne(300, False))

                'regaurdless, we should still get the first message
                Dim msg As EventData = NextMessage
                Assert.AreEqual("Start Blocking Test", msg.Message)

                'Now let's just go nuts on the logger...
                Dim i As Integer = 0
                While i &lt; 100
                    Log.Write("Buffering at {0}%.", i)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Thread.Sleep(100)
                Assert.AreEqual(0, _lastMessages.Count)
                _releaseBlock.[Set]()
                Thread.Sleep(100)
                Assert.IsFalse(_isBlocked.WaitOne(0, False))

                Dim i As Integer = 0
                While i &lt; 100
                    Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
            End Using
        Finally
            Log.LogWrite -= New LogEventHandler(Block_LogWrite)
        End Try</code></example></member>
        <member name="T:Log.Config">
            <summary>
            Provides configuration options for the Log subsystem
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso></member>
        <member name="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)">
            <summary> Changes the log level required to write to a specific output device. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#104" cat="Source Code">Log/Log.cs</seealso><seealso cref="T:CSharpTest.Net.Logging.LogOutputs">LogOutputs</seealso><seealso cref="T:CSharpTest.Net.Logging.LogLevels">LogLevels</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ConfigTest.cs#327">Log/Test/ConfigTest.cs</see></para><code lang="C#">            string origLog = Log.Config.EventLogName;
            string origSrc = Log.Config.EventLogSource;

            Log.Config.EventLogName = "Dua!";
            Assert.AreEqual("Dua!", Log.Config.EventLogName);
            Log.Config.EventLogSource = "Yea.";
            Assert.AreEqual("Yea.", Log.Config.EventLogSource);
            try
            {
                Log.Config.EventLogName = "Application";
                Log.Config.EventLogSource = "MsiInstaller";

                Log.Config.Output = LogOutputs.EventLog;
                Log.Config.SetOutputLevel(LogOutputs.EventLog, LogLevels.Info);
                Log.Write("Logging.Test has hijacked your MsiInstaller source for testing use.  Ignore this message.");
            }
            finally
            {
                RestoreLogState();
                Log.Config.EventLogName = "Application";
                Log.Config.EventLogSource = "Logging.Test";
            }</code><code lang="VB.NET">        Dim origLog As String = Log.Config.EventLogName
        Dim origSrc As String = Log.Config.EventLogSource

        Log.Config.EventLogName = "Dua!"
        Assert.AreEqual("Dua!", Log.Config.EventLogName)
        Log.Config.EventLogSource = "Yea."
        Assert.AreEqual("Yea.", Log.Config.EventLogSource)
        Try
            Log.Config.EventLogName = "Application"
            Log.Config.EventLogSource = "MsiInstaller"

            Log.Config.Output = LogOutputs.EventLog
            Log.Config.SetOutputLevel(LogOutputs.EventLog, LogLevels.Info)
            Log.Write("Logging.Test has hijacked your MsiInstaller source for testing use.  Ignore this message.")
        Finally
            RestoreLogState()
            Log.Config.EventLogName = "Application"
            Log.Config.EventLogSource = "Logging.Test"
        End Try</code></example></member>
        <member name="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)">
            <summary> 
            Changes the output format used to write to a specific output device. The format of this string behaves just like
            EventData.ToString().  The string can contain any public field or property available for the CSharpTest.Net.Logging.EventData 
            class surrounded by braces {} and yes, properties/fields are case sensative.  The input string should look something
            like the following examples: 
            "[{ManagedThreadId:D2}] {Level,8} - {Message}{Location}{Exception}" -- this is the default format of ToString()
            "{EventTime:o} [{ProcessId:D4},{ManagedThreadId:D2}] {Level,8} - {Message}{Location}{Exception}"  -- This is the default log file format.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#137" cat="Source Code">Log/Log.cs</seealso><seealso cref="T:CSharpTest.Net.Logging.LogOutputs">LogOutputs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#117">Log/Test/NegativeTests.cs</see></para><code lang="C#">            string origFile = Log.Config.LogFile;
            try
            {
                Log.Config.Output |= LogOutputs.LogFile;
                Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "{Message}");

                Log.Config.LogFile = @"\\\\\ { &lt;mal formed!? file&gt; ///{0}.txt";
                Log.Write("Hi1");
                Log.Write("Hi2");
                Log.Write("Hi3");
                Assert.AreEqual(this.GetType().FullName + ": Hi3", _lastTrace);
                Log.Config.LogFile = @"C: mal {formatted} file {0}.txt";
                Log.Write("Hi4");
                Log.Write("Hi5");
                Log.Write("Hi6");
                Assert.AreEqual(this.GetType().FullName + ": Hi6", _lastTrace);
                string path = Path.Combine(Path.GetTempPath(), @"my-path-doesnt-exist");
                if (Directory.Exists(path)) Directory.Delete(path, true);
                Log.Config.LogFile = Path.Combine(path, "log.txt");
                Log.Write("Hi!");
                Assert.IsTrue(Directory.Exists(path));
                Assert.IsTrue(File.Exists(Path.Combine(path, "log.txt")));
                Log.Config.LogFile = origFile;
                Directory.Delete(path, true);

                string dir = Environment.CurrentDirectory;
                Environment.CurrentDirectory = Path.GetDirectoryName(origFile);
                Log.Config.LogFile = Path.GetFileName(origFile);
                Assert.AreEqual(origFile, Log.Config.LogFile);
                Environment.CurrentDirectory = dir;
                Assert.AreEqual(origFile, Log.Config.LogFile);
            }
            finally
            {
                Log.Config.LogFile = origFile;
            }</code><code lang="VB.NET">        Dim origFile As String = Log.Config.LogFile
        Try
            Log.Config.Output = Log.Config.Output Or LogOutputs.LogFile
            Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "{Message}")

            Log.Config.LogFile = "\\\\\ { &lt;mal formed!? file&gt; ///{0}.txt"
            Log.Write("Hi1")
            Log.Write("Hi2")
            Log.Write("Hi3")
            Assert.AreEqual(Me.[GetType]().FullName + ": Hi3", _lastTrace)
            Log.Config.LogFile = "C: mal {formatted} file {0}.txt"
            Log.Write("Hi4")
            Log.Write("Hi5")
            Log.Write("Hi6")
            Assert.AreEqual(Me.[GetType]().FullName + ": Hi6", _lastTrace)
            Dim path As String = Path.Combine(Path.GetTempPath(), "my-path-doesnt-exist")
            If Directory.Exists(path) Then
                Directory.Delete(path, True)
            End If
            Log.Config.LogFile = Path.Combine(path, "log.txt")
            Log.Write("Hi!")
            Assert.IsTrue(Directory.Exists(path))
            Assert.IsTrue(File.Exists(Path.Combine(path, "log.txt")))
            Log.Config.LogFile = origFile
            Directory.Delete(path, True)

            Dim dir As String = Environment.CurrentDirectory
            Environment.CurrentDirectory = Path.GetDirectoryName(origFile)
            Log.Config.LogFile = Path.GetFileName(origFile)
            Assert.AreEqual(origFile, Log.Config.LogFile)
            Environment.CurrentDirectory = dir
            Assert.AreEqual(origFile, Log.Config.LogFile)
        Finally
            Log.Config.LogFile = origFile
        End Try</code></example></member>
        <member name="P:Log.Config.Level">
            <summary> Gets or sets the current log LogLevel </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#56" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso><seealso cref="T:CSharpTest.Net.Logging.LogLevels">LogLevels</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#33">Log/Test/NegativeTests.cs</see></para><code lang="C#">            base.Setup();
            Log.Config.Output = LogOutputs.TraceWrite;
            Log.Config.Options = LogOptions.LogAddAssemblyInfo | LogOptions.LogAddFileInfo | LogOptions.Default;
            Log.Config.Level = LogLevels.Verbose;
            Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "NegativeTests: {FULLMESSAGE}");

            _out = Console.Out;
            _error = Console.Error;
            Console.SetOut(new StringWriter());
            Console.SetError(new StringWriter());</code><code lang="VB.NET">        MyBase.Setup()
        Log.Config.Output = LogOutputs.TraceWrite
        Log.Config.Options = LogOptions.LogAddAssemblyInfo Or LogOptions.LogAddFileInfo Or LogOptions.[Default]
        Log.Config.Level = LogLevels.Verbose
        Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "NegativeTests: {FULLMESSAGE}")

        _out = Console.Out
        _error = Console.[Error]
        Console.SetOut(New StringWriter())
        Console.SetError(New StringWriter())</code></example></member>
        <member name="P:Log.Config.Output">
            <summary> Gets or sets the current log LogLevel </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#67" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso><seealso cref="T:CSharpTest.Net.Logging.LogOutputs">LogOutputs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#117">Log/Test/NegativeTests.cs</see></para><code lang="C#">            string origFile = Log.Config.LogFile;
            try
            {
                Log.Config.Output |= LogOutputs.LogFile;
                Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "{Message}");

                Log.Config.LogFile = @"\\\\\ { &lt;mal formed!? file&gt; ///{0}.txt";
                Log.Write("Hi1");
                Log.Write("Hi2");
                Log.Write("Hi3");
                Assert.AreEqual(this.GetType().FullName + ": Hi3", _lastTrace);
                Log.Config.LogFile = @"C: mal {formatted} file {0}.txt";
                Log.Write("Hi4");
                Log.Write("Hi5");
                Log.Write("Hi6");
                Assert.AreEqual(this.GetType().FullName + ": Hi6", _lastTrace);
                string path = Path.Combine(Path.GetTempPath(), @"my-path-doesnt-exist");
                if (Directory.Exists(path)) Directory.Delete(path, true);
                Log.Config.LogFile = Path.Combine(path, "log.txt");
                Log.Write("Hi!");
                Assert.IsTrue(Directory.Exists(path));
                Assert.IsTrue(File.Exists(Path.Combine(path, "log.txt")));
                Log.Config.LogFile = origFile;
                Directory.Delete(path, true);

                string dir = Environment.CurrentDirectory;
                Environment.CurrentDirectory = Path.GetDirectoryName(origFile);
                Log.Config.LogFile = Path.GetFileName(origFile);
                Assert.AreEqual(origFile, Log.Config.LogFile);
                Environment.CurrentDirectory = dir;
                Assert.AreEqual(origFile, Log.Config.LogFile);
            }
            finally
            {
                Log.Config.LogFile = origFile;
            }</code><code lang="VB.NET">        Dim origFile As String = Log.Config.LogFile
        Try
            Log.Config.Output = Log.Config.Output Or LogOutputs.LogFile
            Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "{Message}")

            Log.Config.LogFile = "\\\\\ { &lt;mal formed!? file&gt; ///{0}.txt"
            Log.Write("Hi1")
            Log.Write("Hi2")
            Log.Write("Hi3")
            Assert.AreEqual(Me.[GetType]().FullName + ": Hi3", _lastTrace)
            Log.Config.LogFile = "C: mal {formatted} file {0}.txt"
            Log.Write("Hi4")
            Log.Write("Hi5")
            Log.Write("Hi6")
            Assert.AreEqual(Me.[GetType]().FullName + ": Hi6", _lastTrace)
            Dim path As String = Path.Combine(Path.GetTempPath(), "my-path-doesnt-exist")
            If Directory.Exists(path) Then
                Directory.Delete(path, True)
            End If
            Log.Config.LogFile = Path.Combine(path, "log.txt")
            Log.Write("Hi!")
            Assert.IsTrue(Directory.Exists(path))
            Assert.IsTrue(File.Exists(Path.Combine(path, "log.txt")))
            Log.Config.LogFile = origFile
            Directory.Delete(path, True)

            Dim dir As String = Environment.CurrentDirectory
            Environment.CurrentDirectory = Path.GetDirectoryName(origFile)
            Log.Config.LogFile = Path.GetFileName(origFile)
            Assert.AreEqual(origFile, Log.Config.LogFile)
            Environment.CurrentDirectory = dir
            Assert.AreEqual(origFile, Log.Config.LogFile)
        Finally
            Log.Config.LogFile = origFile
        End Try</code></example></member>
        <member name="P:Log.Config.Options">
            <summary> 
            Gets or sets the availability of stack info etc.  The following performance characterists were taken with a 
            simple example app running 10 threads each writing 1000 log statements in a tight-loop.  The times below reflect
            threading enabled (someone having called Log.AppStart()).  The following hardware was used:
            AMD Turion 64x2 TL-62  2.10 GHz, 3 GB RAM running Vista 32-bit SP1  (HP Notebook).  The time indicated below
            was estimated by taking the total number of milliseconds until all threads completed and dividing by the 10,000
            messages that were written.
            <list>
            	<item>Cost per call 0.005 ms with no context   (None)</item>
            	<item>Cost per call 0.035 ms with calling method   (LogImmediateCaller)</item>
            	<item>Cost per call 0.060 ms with calling method &amp; assembly info   (LogImmediateCaller | LogAddAssemblyInfo)</item>
            	<item>Cost per call 0.160 ms with calling method &amp; file info   (LogImmediateCaller | LogAddFileInfo)</item>
            	<item>Cost per call 0.190 ms with calling method &amp; assembly info &amp; file info   (LogImmediateCaller | LogAddAssemblyInfo | LogAddFileInfo)</item>
            </list>
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#92" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso><seealso cref="T:CSharpTest.Net.Logging.LogOptions">LogOptions</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#33">Log/Test/NegativeTests.cs</see></para><code lang="C#">            base.Setup();
            Log.Config.Output = LogOutputs.TraceWrite;
            Log.Config.Options = LogOptions.LogAddAssemblyInfo | LogOptions.LogAddFileInfo | LogOptions.Default;
            Log.Config.Level = LogLevels.Verbose;
            Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "NegativeTests: {FULLMESSAGE}");

            _out = Console.Out;
            _error = Console.Error;
            Console.SetOut(new StringWriter());
            Console.SetError(new StringWriter());</code><code lang="VB.NET">        MyBase.Setup()
        Log.Config.Output = LogOutputs.TraceWrite
        Log.Config.Options = LogOptions.LogAddAssemblyInfo Or LogOptions.LogAddFileInfo Or LogOptions.[Default]
        Log.Config.Level = LogLevels.Verbose
        Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "NegativeTests: {FULLMESSAGE}")

        _out = Console.Out
        _error = Console.[Error]
        Console.SetOut(New StringWriter())
        Console.SetError(New StringWriter())</code></example></member>
        <member name="P:Log.Config.FormatProvider">
            <summary> Gets or sets the format provider to use when formatting strings </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#99" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ConfigTest.cs#87">Log/Test/ConfigTest.cs</see></para><code lang="C#">            DateTime now = DateTime.Now;
            string cultured = String.Format("{0}", now);
            string invariant = String.Format(CultureInfo.InvariantCulture, "{0}", now);

            Log.Write("{0}", now);
            Assert.IsTrue(_lastTrace.StartsWith(GetType().FullName + ": "));
            string trimed = _lastTrace.Substring(GetType().FullName.Length + 2);

            Assert.AreEqual(invariant, trimed);

            Log.Config.FormatProvider = CultureInfo.CurrentCulture;
            Log.Write("{0}", now);
            Assert.IsTrue(_lastTrace.StartsWith(GetType().FullName + ": "));
            trimed = _lastTrace.Substring(GetType().FullName.Length + 2);

            Assert.AreEqual(cultured, trimed);
    
            Log.Config.FormatProvider = CultureInfo.InvariantCulture;
            Log.Write("{0}", now);
            Assert.IsTrue(_lastTrace.StartsWith(GetType().FullName + ": "));
            trimed = _lastTrace.Substring(GetType().FullName.Length + 2);

            Assert.AreEqual(invariant, trimed);</code><code lang="VB.NET">        Dim now As DateTime = DateTime.Now
        Dim cultured As String = [String].Format("{0}", now)
        Dim invariant As String = [String].Format(CultureInfo.InvariantCulture, "{0}", now)

        Log.Write("{0}", now)
        Assert.IsTrue(_lastTrace.StartsWith([GetType]().FullName + ": "))
        Dim trimed As String = _lastTrace.Substring([GetType]().FullName.Length + 2)

        Assert.AreEqual(invariant, trimed)

        Log.Config.FormatProvider = CultureInfo.CurrentCulture
        Log.Write("{0}", now)
        Assert.IsTrue(_lastTrace.StartsWith([GetType]().FullName + ": "))
        trimed = _lastTrace.Substring([GetType]().FullName.Length + 2)

        Assert.AreEqual(cultured, trimed)

        Log.Config.FormatProvider = CultureInfo.InvariantCulture
        Log.Write("{0}", now)
        Assert.IsTrue(_lastTrace.StartsWith([GetType]().FullName + ": "))
        trimed = _lastTrace.Substring([GetType]().FullName.Length + 2)

        Assert.AreEqual(invariant, trimed)</code></example></member>
        <member name="P:Log.Config.LogFile">
            <summary>
            Gets or sets the current log file name, insert '{0}' in the file's name to allow log rolling
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#167" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#117">Log/Test/NegativeTests.cs</see></para><code lang="C#">            string origFile = Log.Config.LogFile;
            try
            {
                Log.Config.Output |= LogOutputs.LogFile;
                Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "{Message}");

                Log.Config.LogFile = @"\\\\\ { &lt;mal formed!? file&gt; ///{0}.txt";
                Log.Write("Hi1");
                Log.Write("Hi2");
                Log.Write("Hi3");
                Assert.AreEqual(this.GetType().FullName + ": Hi3", _lastTrace);
                Log.Config.LogFile = @"C: mal {formatted} file {0}.txt";
                Log.Write("Hi4");
                Log.Write("Hi5");
                Log.Write("Hi6");
                Assert.AreEqual(this.GetType().FullName + ": Hi6", _lastTrace);
                string path = Path.Combine(Path.GetTempPath(), @"my-path-doesnt-exist");
                if (Directory.Exists(path)) Directory.Delete(path, true);
                Log.Config.LogFile = Path.Combine(path, "log.txt");
                Log.Write("Hi!");
                Assert.IsTrue(Directory.Exists(path));
                Assert.IsTrue(File.Exists(Path.Combine(path, "log.txt")));
                Log.Config.LogFile = origFile;
                Directory.Delete(path, true);

                string dir = Environment.CurrentDirectory;
                Environment.CurrentDirectory = Path.GetDirectoryName(origFile);
                Log.Config.LogFile = Path.GetFileName(origFile);
                Assert.AreEqual(origFile, Log.Config.LogFile);
                Environment.CurrentDirectory = dir;
                Assert.AreEqual(origFile, Log.Config.LogFile);
            }
            finally
            {
                Log.Config.LogFile = origFile;
            }</code><code lang="VB.NET">        Dim origFile As String = Log.Config.LogFile
        Try
            Log.Config.Output = Log.Config.Output Or LogOutputs.LogFile
            Log.Config.SetOutputFormat(LogOutputs.TraceWrite, "{Message}")

            Log.Config.LogFile = "\\\\\ { &lt;mal formed!? file&gt; ///{0}.txt"
            Log.Write("Hi1")
            Log.Write("Hi2")
            Log.Write("Hi3")
            Assert.AreEqual(Me.[GetType]().FullName + ": Hi3", _lastTrace)
            Log.Config.LogFile = "C: mal {formatted} file {0}.txt"
            Log.Write("Hi4")
            Log.Write("Hi5")
            Log.Write("Hi6")
            Assert.AreEqual(Me.[GetType]().FullName + ": Hi6", _lastTrace)
            Dim path As String = Path.Combine(Path.GetTempPath(), "my-path-doesnt-exist")
            If Directory.Exists(path) Then
                Directory.Delete(path, True)
            End If
            Log.Config.LogFile = Path.Combine(path, "log.txt")
            Log.Write("Hi!")
            Assert.IsTrue(Directory.Exists(path))
            Assert.IsTrue(File.Exists(Path.Combine(path, "log.txt")))
            Log.Config.LogFile = origFile
            Directory.Delete(path, True)

            Dim dir As String = Environment.CurrentDirectory
            Environment.CurrentDirectory = Path.GetDirectoryName(origFile)
            Log.Config.LogFile = Path.GetFileName(origFile)
            Assert.AreEqual(origFile, Log.Config.LogFile)
            Environment.CurrentDirectory = dir
            Assert.AreEqual(origFile, Log.Config.LogFile)
        Finally
            Log.Config.LogFile = origFile
        End Try</code></example></member>
        <member name="P:Log.Config.LogFileMaxSize">
            <summary> Gets or sets the maximum size in bytes the log file is allowed to be before rolling to history </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#184" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso></member>
        <member name="P:Log.Config.LogFileMaxHistory">
            <summary> Gets or sets the maximum number of history log files to keep on the system </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#186" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso></member>
        <member name="P:Log.Config.EventLogName">
            <summary> Sets the event log name we will write events to. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#189" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ConfigTest.cs#327">Log/Test/ConfigTest.cs</see></para><code lang="C#">            string origLog = Log.Config.EventLogName;
            string origSrc = Log.Config.EventLogSource;

            Log.Config.EventLogName = "Dua!";
            Assert.AreEqual("Dua!", Log.Config.EventLogName);
            Log.Config.EventLogSource = "Yea.";
            Assert.AreEqual("Yea.", Log.Config.EventLogSource);
            try
            {
                Log.Config.EventLogName = "Application";
                Log.Config.EventLogSource = "MsiInstaller";

                Log.Config.Output = LogOutputs.EventLog;
                Log.Config.SetOutputLevel(LogOutputs.EventLog, LogLevels.Info);
                Log.Write("Logging.Test has hijacked your MsiInstaller source for testing use.  Ignore this message.");
            }
            finally
            {
                RestoreLogState();
                Log.Config.EventLogName = "Application";
                Log.Config.EventLogSource = "Logging.Test";
            }</code><code lang="VB.NET">        Dim origLog As String = Log.Config.EventLogName
        Dim origSrc As String = Log.Config.EventLogSource

        Log.Config.EventLogName = "Dua!"
        Assert.AreEqual("Dua!", Log.Config.EventLogName)
        Log.Config.EventLogSource = "Yea."
        Assert.AreEqual("Yea.", Log.Config.EventLogSource)
        Try
            Log.Config.EventLogName = "Application"
            Log.Config.EventLogSource = "MsiInstaller"

            Log.Config.Output = LogOutputs.EventLog
            Log.Config.SetOutputLevel(LogOutputs.EventLog, LogLevels.Info)
            Log.Write("Logging.Test has hijacked your MsiInstaller source for testing use.  Ignore this message.")
        Finally
            RestoreLogState()
            Log.Config.EventLogName = "Application"
            Log.Config.EventLogSource = "Logging.Test"
        End Try</code></example></member>
        <member name="P:Log.Config.EventLogSource">
            <summary> Sets the event log source we will write events with, It's up to you to register this value. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.cs#191" cat="Source Code">Log/Log.cs</seealso><seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ConfigTest.cs#327">Log/Test/ConfigTest.cs</see></para><code lang="C#">            string origLog = Log.Config.EventLogName;
            string origSrc = Log.Config.EventLogSource;

            Log.Config.EventLogName = "Dua!";
            Assert.AreEqual("Dua!", Log.Config.EventLogName);
            Log.Config.EventLogSource = "Yea.";
            Assert.AreEqual("Yea.", Log.Config.EventLogSource);
            try
            {
                Log.Config.EventLogName = "Application";
                Log.Config.EventLogSource = "MsiInstaller";

                Log.Config.Output = LogOutputs.EventLog;
                Log.Config.SetOutputLevel(LogOutputs.EventLog, LogLevels.Info);
                Log.Write("Logging.Test has hijacked your MsiInstaller source for testing use.  Ignore this message.");
            }
            finally
            {
                RestoreLogState();
                Log.Config.EventLogName = "Application";
                Log.Config.EventLogSource = "Logging.Test";
            }</code><code lang="VB.NET">        Dim origLog As String = Log.Config.EventLogName
        Dim origSrc As String = Log.Config.EventLogSource

        Log.Config.EventLogName = "Dua!"
        Assert.AreEqual("Dua!", Log.Config.EventLogName)
        Log.Config.EventLogSource = "Yea."
        Assert.AreEqual("Yea.", Log.Config.EventLogSource)
        Try
            Log.Config.EventLogName = "Application"
            Log.Config.EventLogSource = "MsiInstaller"

            Log.Config.Output = LogOutputs.EventLog
            Log.Config.SetOutputLevel(LogOutputs.EventLog, LogLevels.Info)
            Log.Write("Logging.Test has hijacked your MsiInstaller source for testing use.  Ignore this message.")
        Finally
            RestoreLogState()
            Log.Config.EventLogName = "Application"
            Log.Config.EventLogSource = "Logging.Test"
        End Try</code></example></member>
        <member name="T:CSharpTest.Net.Logging.LogEventHandler">
            <summary>
            Log events are raised with this event handler
            </summary>
        <example><para><see cref="http://csharptest.net/browse/src/Log/Test/ThreadedLogTest.cs#50">Log/Test/ThreadedLogTest.cs</see></para><code lang="C#">            Log.LogWrite += new LogEventHandler(Block_LogWrite);
            try
            {
                using (Log.Start("Blocking Test"))
                {
                    //the start above should already get us in a blocked state:
                    Assert.IsTrue(_isBlocked.WaitOne(300, false));

                    //regaurdless, we should still get the first message
                    EventData msg = NextMessage;
                    Assert.AreEqual("Start Blocking Test", msg.Message);

                    //Now let's just go nuts on the logger...
                    for (int i = 0; i &lt; 100; i++)
                        Log.Write("Buffering at {0}%.", i);

                    Thread.Sleep(100);
                    Assert.AreEqual(0, _lastMessages.Count);
                    _releaseBlock.Set();
                    Thread.Sleep(100);
                    Assert.IsFalse(_isBlocked.WaitOne(0, false));

                    for (int i = 0; i &lt; 100; i++)
                        Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"));
                }
            }
            finally
            {
                Log.LogWrite -= new LogEventHandler(Block_LogWrite);
            }</code><code lang="VB.NET">        Log.LogWrite += New LogEventHandler(Block_LogWrite)
        Try
            Using Log.Start("Blocking Test")
                'the start above should already get us in a blocked state:
                Assert.IsTrue(_isBlocked.WaitOne(300, False))

                'regaurdless, we should still get the first message
                Dim msg As EventData = NextMessage
                Assert.AreEqual("Start Blocking Test", msg.Message)

                'Now let's just go nuts on the logger...
                Dim i As Integer = 0
                While i &lt; 100
                    Log.Write("Buffering at {0}%.", i)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Thread.Sleep(100)
                Assert.AreEqual(0, _lastMessages.Count)
                _releaseBlock.[Set]()
                Thread.Sleep(100)
                Assert.IsFalse(_isBlocked.WaitOne(0, False))

                Dim i As Integer = 0
                While i &lt; 100
                    Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
            End Using
        Finally
            Log.LogWrite -= New LogEventHandler(Block_LogWrite)
        End Try</code></example></member>
        <member name="T:CSharpTest.Net.Logging.LogEventArgs">
            <summary>
            The event args passed to the log system, often multiple log entries will arrive 
            'near' simultaneous, ALWAYs allow for ZERO or more than one.
            </summary>
        <seealso cref="M:CSharpTest.Net.Logging.LogEventHandler.Invoke(System.Object,CSharpTest.Net.Logging.LogEventArgs)">LogEventHandler.Invoke(Object,LogEventArgs)</seealso><seealso cref="M:CSharpTest.Net.Logging.LogEventHandler.BeginInvoke(System.Object,CSharpTest.Net.Logging.LogEventArgs,System.AsyncCallback,System.Object)">IAsyncResult LogEventHandler.BeginInvoke(Object,LogEventArgs,AsyncCallback,Object)</seealso><seealso cref="http://csharptest.net/browse/src/Log/Log.Event.cs" cat="Source Code">Log/Log.Event.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="M:CSharpTest.Net.Logging.LogEventArgs.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> /// Serialization Constructor for ISerializable /// </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.Event.cs#50" cat="Source Code">Log/Log.Event.cs</seealso></member>
        <member name="M:CSharpTest.Net.Logging.LogEventArgs.#ctor(System.Collections.Generic.List{CSharpTest.Net.Logging.EventData})">
            <summary>
            Constructs a list event log dataList to be provided the Log.LogWrite event
            </summary>
        </member>
        <member name="M:CSharpTest.Net.Logging.LogEventArgs.ToArray">
            <summary>
            Returns the items as an array of EventData
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.Event.cs#81" cat="Source Code">Log/Log.Event.cs</seealso><seealso cref="T:CSharpTest.Net.Logging.EventData">EventData</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="M:CSharpTest.Net.Logging.LogEventArgs.ToString">
            <summary>
            Returns the entire collection of EventData records as a single line-delimited string
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.Event.cs#86" cat="Source Code">Log/Log.Event.cs</seealso></member>
        <member name="M:CSharpTest.Net.Logging.LogEventArgs.GetEnumerator">
            <summary>
            Returns the enumeration of the EventData structures
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.Event.cs#107" cat="Source Code">Log/Log.Event.cs</seealso></member>
        <member name="M:CSharpTest.Net.Logging.LogEventArgs.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns the non-generic version of the enumeration
            </summary>
            <returns></returns>
        </member>
        <member name="P:CSharpTest.Net.Logging.LogEventArgs.Count">
            <summary>
            Returns the count of items in the collection
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.Event.cs#77" cat="Source Code">Log/Log.Event.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="T:CSharpTest.Net.Logging.EventData">
            <summary>
            This is the class that is used to transfer log events through the system. It's basically
            a 'picture' of the state at the time the log was written since all logging is actually
            happening in a delayed fashion.
            </summary>
        <seealso cref="M:CSharpTest.Net.Logging.LogEventArgs.ToArray">EventData[] LogEventArgs.ToArray()</seealso><seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="M:CSharpTest.Net.Logging.EventData.#cctor">
            <summary>
            Asserts that the LogFields enumeration has the same fields as this class
            </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.EventData.Level">
            <summary> The LogLevel of the log data or LogLevels.None if Log.Write() was called </summary>
        </member>
        <member name="F:CSharpTest.Net.Logging.EventData.Output">
            <summary> The outputs that should recieve this message </summary>
        </member>
        <member name="M:CSharpTest.Net.Logging.EventData.ToObjectArray">
            <summary>
            Used for string formatting, the order of these MUST match the order of names return by FieldNames
            </summary>
        <seealso cref="M:CSharpTest.Net.Logging.EventData.ToString(System.String)" cat="Used By">String EventData.ToString(String)</seealso><seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter)" cat="Used By">EventData.Write(TextWriter)</seealso><seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter,System.String)" cat="Used By">EventData.Write(TextWriter,String)</seealso></member>
        <member name="M:CSharpTest.Net.Logging.EventData.ToString">
            <summary>
            Displays this log data in a default brief format
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#149" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="M:CSharpTest.Net.Logging.EventData.ToString(System.String)">
            <summary>
            Displays this log data in a specific format.  Use '{FieldName}' to be substituded with it's value.
            Sorry but it uses a case-sensitive match of fields in this class.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#159" cat="Source Code">Log/Log.EventData.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter)">
            <summary>
            Writes this event to the text writter with the default brief format
            </summary>
        <seealso cref="M:CSharpTest.Net.Logging.LogEventArgs.ToString" cat="Used By">String LogEventArgs.ToString()</seealso><seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#169" cat="Source Code">Log/Log.EventData.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter,System.String)">
            <summary>
            Writes this log data in a specific format.  Use '{FieldName}' to be substituded with it's value.
            Sorry but it uses a case-sensitive match of fields in this class.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#179" cat="Source Code">Log/Log.EventData.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="M:CSharpTest.Net.Logging.EventData.Write(System.Xml.XmlWriter)">
            <summary>
            Writes a custom xml format for this record.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#188" cat="Source Code">Log/Log.EventData.cs</seealso><seealso cref="M:CSharpTest.Net.Logging.EventData.ToXml" cat="Used By">String EventData.ToXml()</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="M:CSharpTest.Net.Logging.EventData.ToXml">
            <summary>
            Returns this data as an XmlWriter text fragment who name is the class name and each attribute
            is the field name, again maintaining the case.
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#232" cat="Source Code">Log/Log.EventData.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/BasicLogTest.cs#240">Log/Test/BasicLogTest.cs</see></para><code lang="C#">            Log.Write("");
            EventData msg = LastMessage;
            Assert.IsNull(msg.LogCurrent);
            Assert.IsNull(msg.LogStack);

            using (Log.Start(UniqueData))
            {
                msg = LastMessage;
                Assert.AreEqual("Start " + UniqueData, msg.Message);
                Assert.AreEqual(UniqueData, msg.LogCurrent);
                Assert.AreEqual(msg.LogCurrent, msg.LogStack);

                using (Log.Start("2ndlevel"))
                {
                    msg = LastMessage;
                    Assert.AreEqual("Start 2ndlevel", msg.Message);
                    Assert.AreEqual("2ndlevel", msg.LogCurrent);
                    Assert.AreEqual(UniqueData + "::2ndlevel", msg.LogStack);

                    Assert.IsTrue(msg.ToXml().Contains("2ndlevel"));
                    Assert.AreEqual("2ndlevel", msg.ToString("{LogCurrent}"));
                }
                msg = LastMessage;
                Assert.IsTrue(msg.Message.StartsWith("End 2ndlevel"));
                Assert.AreEqual(UniqueData, msg.LogCurrent);
                Assert.AreEqual(msg.LogCurrent, msg.LogStack);
            }
            msg = LastMessage;
            Assert.IsTrue(msg.Message.StartsWith("End " + UniqueData));
            Assert.IsNull(msg.LogCurrent);
            Assert.IsNull(msg.LogStack);</code><code lang="VB.NET">        Log.Write("")
        Dim msg As EventData = LastMessage
        Assert.IsNull(msg.LogCurrent)
        Assert.IsNull(msg.LogStack)

        Using Log.Start(UniqueData)
            msg = LastMessage
            Assert.AreEqual("Start " + UniqueData, msg.Message)
            Assert.AreEqual(UniqueData, msg.LogCurrent)
            Assert.AreEqual(msg.LogCurrent, msg.LogStack)

            Using Log.Start("2ndlevel")
                msg = LastMessage
                Assert.AreEqual("Start 2ndlevel", msg.Message)
                Assert.AreEqual("2ndlevel", msg.LogCurrent)
                Assert.AreEqual(UniqueData + "::2ndlevel", msg.LogStack)

                Assert.IsTrue(msg.ToXml().Contains("2ndlevel"))
                Assert.AreEqual("2ndlevel", msg.ToString("{LogCurrent}"))
            End Using
            msg = LastMessage
            Assert.IsTrue(msg.Message.StartsWith("End 2ndlevel"))
            Assert.AreEqual(UniqueData, msg.LogCurrent)
            Assert.AreEqual(msg.LogCurrent, msg.LogStack)
        End Using
        msg = LastMessage
        Assert.IsTrue(msg.Message.StartsWith("End " + UniqueData))
        Assert.IsNull(msg.LogCurrent)
        Assert.IsNull(msg.LogStack)</code></example></member>
        <member name="M:CSharpTest.Net.Logging.EventData.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary> /// Serialization Constructor for ISerializable /// </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#246" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.EventId">
            <summary> A unique integer representing the index the event was written since program start </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#55" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.EventTime">
            <summary> Returns the time when the log event was raised </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#57" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.ProcessId">
            <summary> The current process id </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#60" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.ProcessName">
            <summary> The current process name </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#62" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.AppDomainName">
            <summary> The current app domain's friendly name </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#64" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.EntryAssembly">
            <summary> The current app domain's entry-point assembly name </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#66" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.ThreadPrincipalName">
            <summary> The logging thread's 'CurrentPrincipal.Identity.Name' property </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#68" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.ManagedThreadId">
            <summary> The managed thread id that called the log routine </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#71" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.ManagedThreadName">
            <summary> The managed thread name (if any) or String.Empty </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#73" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.Exception">
            <summary> An instance of the Exception class or null if none provided </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#80" cat="Source Code">Log/Log.EventData.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/NegativeTests.cs#158">Log/Test/NegativeTests.cs</see></para><code lang="C#">            Log.LogWrite += BreakIn_LogWrite;
            try
            {

                string message = "Bad {500} Data: {0}";
                Exception myError = i_blow_up;
                LogEventArgs arg1 = null;

                LogEventHandler eh = new LogEventHandler(delegate(object s, LogEventArgs e) { arg1 = e; });
                Log.LogWrite += eh;
                Log.LogWrite += BreakIn_LogWrite;
                Log.Error(myError, message, i_blow_up);
                Log.LogWrite -= eh;
                Log.LogWrite -= BreakIn_LogWrite;

                Assert.IsNotNull(arg1);
                Assert.AreEqual(1, arg1.Count);
                Assert.AreEqual(1, arg1.ToArray().Length);

                EventData data = arg1.ToArray()[0];
                Assert.IsNotNull(data);
                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, myError.GetType());

                Assert.IsTrue(data.ToString().Contains(message));
                Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message));
                Assert.IsTrue(data.ToString("{Exception}").Contains(myError.GetType().FullName));

                data.Write((System.Xml.XmlTextWriter)null);
                System.Xml.XmlTextWriter wtr = new System.Xml.XmlTextWriter(new MemoryStream(new byte[10]), System.Text.Encoding.UTF32);
                data.Write(wtr);

                data.Write(new StreamWriter(new MemoryStream(new byte[10])));
                foreach (string format in badFormats)
                    data.Write(new StreamWriter(new MemoryStream(new byte[10])), format);

                BinaryFormatter ser = new BinaryFormatter();
                MemoryStream ms = new MemoryStream();

                ser.Serialize(ms, arg1);
                Assert.Greater((int)ms.Position, 0);

                ms.Position = 0;
                object restored = ser.Deserialize(ms);
                Assert.IsNotNull(restored);
                Assert.AreEqual(typeof(LogEventArgs), restored.GetType());
                LogEventArgs arg2 = restored as LogEventArgs;

                Assert.IsNotNull(arg2);
                Assert.AreEqual(1, arg2.Count);
                Assert.AreEqual(1, arg2.ToArray().Length);

                data = arg2.ToArray()[0];
                Assert.IsNotNull(data);

                Assert.IsNotNull(data.Exception);
                Assert.AreNotEqual(myError.GetType(), data.Exception.GetType());
                Assert.AreEqual(typeof(Log).Assembly, data.Exception.GetType().Assembly);
                Assert.IsTrue(data.Exception.Message.Contains(myError.GetType().FullName));
                Assert.IsNotNull(data.Exception.ToString());
                Assert.AreNotEqual(String.Empty, data.Exception.ToString());
                Assert.IsTrue(data.Exception.ToString().Contains(myError.GetType().FullName));

                BasicLogTest.AssertMessage(GetType(), null, data, LogLevels.Error, null, data.Exception.GetType());

                System.Runtime.Serialization.SerializationInfo info = new System.Runtime.Serialization.SerializationInfo(data.Exception.GetType(), new myconverter());
                System.Runtime.Serialization.StreamingContext ctx = new System.Runtime.Serialization.StreamingContext();

                Exception err = (Exception)
                    data.Exception.GetType().InvokeMember(null, System.Reflection.BindingFlags.CreateInstance,
                    null, null, new object[] { info, ctx });

                Assert.IsNotNull(err.Message);
                Assert.IsNotEmpty(err.Message);
                Assert.IsNotNull(err.ToString());
                Assert.IsNotEmpty(err.ToString());
            }
            finally
            {
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
                Log.LogWrite -= BreakIn_LogWrite;
            }</code><code lang="VB.NET">        Log.LogWrite += BreakIn_LogWrite
        Try

            Dim message As String = "Bad {500} Data: {0}"
            Dim myError As Exception = i_blow_up
            Dim arg1 As LogEventArgs = Nothing

            Dim eh As New LogEventHandler(Function(s As Object, e As LogEventArgs) Do
                arg1 = e
            End Function)
            Log.LogWrite += eh
            Log.LogWrite += BreakIn_LogWrite
            Log.[Error](myError, message, i_blow_up)
            Log.LogWrite -= eh
            Log.LogWrite -= BreakIn_LogWrite

            Assert.IsNotNull(arg1)
            Assert.AreEqual(1, arg1.Count)
            Assert.AreEqual(1, arg1.ToArray().Length)

            Dim data As EventData = arg1.ToArray()(0)
            Assert.IsNotNull(data)
            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, myError.[GetType]())

            Assert.IsTrue(data.ToString().Contains(message))
            Assert.IsTrue(data.ToString("{Message:%s!} {}").Contains(message))
            Assert.IsTrue(data.ToString("{Exception}").Contains(myError.[GetType]().FullName))

            data.Write(DirectCast(Nothing, System.Xml.XmlTextWriter))
            Dim wtr As New System.Xml.XmlTextWriter(New MemoryStream(New Byte(10) {}), System.Text.Encoding.UTF32)
            data.Write(wtr)

            data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})))
            For Each format As String In badFormats
                data.Write(New StreamWriter(New MemoryStream(New Byte(10) {})), format)
            Next

            Dim ser As New BinaryFormatter()
            Dim ms As New MemoryStream()

            ser.Serialize(ms, arg1)
            Assert.Greater(DirectCast(ms.Position, Integer), 0)

            ms.Position = 0
            Dim restored As Object = ser.Deserialize(ms)
            Assert.IsNotNull(restored)
            Assert.AreEqual(GetType(LogEventArgs), restored.[GetType]())
            Dim arg2 As LogEventArgs = TryCast(restored, LogEventArgs)

            Assert.IsNotNull(arg2)
            Assert.AreEqual(1, arg2.Count)
            Assert.AreEqual(1, arg2.ToArray().Length)

            data = arg2.ToArray()(0)
            Assert.IsNotNull(data)

            Assert.IsNotNull(data.Exception)
            Assert.AreNotEqual(myError.[GetType](), data.Exception.[GetType]())
            Assert.AreEqual(GetType(Log).Assembly, data.Exception.[GetType]().Assembly)
            Assert.IsTrue(data.Exception.Message.Contains(myError.[GetType]().FullName))
            Assert.IsNotNull(data.Exception.ToString())
            Assert.AreNotEqual([String].Empty, data.Exception.ToString())
            Assert.IsTrue(data.Exception.ToString().Contains(myError.[GetType]().FullName))

            BasicLogTest.AssertMessage([GetType](), Nothing, data, LogLevels.[Error], Nothing, data.Exception.[GetType]())

            Dim info As New System.Runtime.Serialization.SerializationInfo(data.Exception.[GetType](), New myconverter())
            Dim ctx As New System.Runtime.Serialization.StreamingContext()

            Dim err As Exception = DirectCast(data.Exception.[GetType]().InvokeMember(Nothing, System.Reflection.BindingFlags.CreateInstance, Nothing, Nothing, New Object() {info, ctx}), Exception)

            Assert.IsNotNull(err.Message)
            Assert.IsNotEmpty(err.Message)
            Assert.IsNotNull(err.ToString())
            Assert.IsNotEmpty(err.ToString())
        Finally
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
            Log.LogWrite -= BreakIn_LogWrite
        End Try</code></example></member>
        <member name="P:CSharpTest.Net.Logging.EventData.Message">
            <summary> The formatted string of the message or String.Empty if none </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#82" cat="Source Code">Log/Log.EventData.cs</seealso><seealso cref="M:CSharpTest.Net.Logging.EventData.ToString(System.String)" cat="Used By">String EventData.ToString(String)</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/ThreadedLogTest.cs#50">Log/Test/ThreadedLogTest.cs</see></para><code lang="C#">            Log.LogWrite += new LogEventHandler(Block_LogWrite);
            try
            {
                using (Log.Start("Blocking Test"))
                {
                    //the start above should already get us in a blocked state:
                    Assert.IsTrue(_isBlocked.WaitOne(300, false));

                    //regaurdless, we should still get the first message
                    EventData msg = NextMessage;
                    Assert.AreEqual("Start Blocking Test", msg.Message);

                    //Now let's just go nuts on the logger...
                    for (int i = 0; i &lt; 100; i++)
                        Log.Write("Buffering at {0}%.", i);

                    Thread.Sleep(100);
                    Assert.AreEqual(0, _lastMessages.Count);
                    _releaseBlock.Set();
                    Thread.Sleep(100);
                    Assert.IsFalse(_isBlocked.WaitOne(0, false));

                    for (int i = 0; i &lt; 100; i++)
                        Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"));
                }
            }
            finally
            {
                Log.LogWrite -= new LogEventHandler(Block_LogWrite);
            }</code><code lang="VB.NET">        Log.LogWrite += New LogEventHandler(Block_LogWrite)
        Try
            Using Log.Start("Blocking Test")
                'the start above should already get us in a blocked state:
                Assert.IsTrue(_isBlocked.WaitOne(300, False))

                'regaurdless, we should still get the first message
                Dim msg As EventData = NextMessage
                Assert.AreEqual("Start Blocking Test", msg.Message)

                'Now let's just go nuts on the logger...
                Dim i As Integer = 0
                While i &lt; 100
                    Log.Write("Buffering at {0}%.", i)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Thread.Sleep(100)
                Assert.AreEqual(0, _lastMessages.Count)
                _releaseBlock.[Set]()
                Thread.Sleep(100)
                Assert.IsFalse(_isBlocked.WaitOne(0, False))

                Dim i As Integer = 0
                While i &lt; 100
                    Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
            End Using
        Finally
            Log.LogWrite -= New LogEventHandler(Block_LogWrite)
        End Try</code></example></member>
        <member name="P:CSharpTest.Net.Logging.EventData.FileName">
            <summary> The file name where the log was called from or null if no file dataList available/configured. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#85" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.FileLine">
            <summary> The file line number where the log was called from. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#87" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.FileColumn">
            <summary> The file column where the log was called from. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#89" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.MethodAssemblyVersion">
            <summary> The assembly's version that contained the method where the log was called from. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#92" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.MethodAssembly">
            <summary> The assembly's name that contained the method where the log was called from. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#94" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.MethodType">
            <summary> The type containing the method where the log was called from. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#96" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.MethodTypeName">
            <summary> The unqualified type containing the method where the log was called from. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#98" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.MethodName">
            <summary> The method where the log was called from. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#101" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.MethodArgs">
            <summary> The method's argument names and types. </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#103" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.IlOffset">
            <summary> Returns the IL offset within the calling method </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#105" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.LogCurrent">
            <summary> returns the text given the most recent call to Log.Start() that has not yet been Disponsed</summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#108" cat="Source Code">Log/Log.EventData.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/BasicLogTest.cs#276">Log/Test/BasicLogTest.cs</see></para><code lang="C#">            Log.Write(UniqueData);
            EventData msg = LastMessage;
            Assert.IsNull(msg.LogCurrent);
            Assert.IsNull(msg.LogStack);

            using (Log.Start(UniqueData))
            {
                msg = LastMessage;
                Assert.AreEqual("Start " + UniqueData, msg.Message);
                Assert.AreEqual(UniqueData, msg.LogCurrent);
                Assert.AreEqual(msg.LogCurrent, msg.LogStack);

                Log.ClearStack();
                Log.Warning("Stack cleared");
                msg = LastMessage;
                Assert.IsNull(msg.LogCurrent);
                Assert.IsNull(msg.LogStack);
            }

            //no message generated.
            Assert.AreEqual(0, _lastMessages.Count);
            Assert.IsNull(msg.LogCurrent);
            Assert.IsNull(msg.LogStack);</code><code lang="VB.NET">        Log.Write(UniqueData)
        Dim msg As EventData = LastMessage
        Assert.IsNull(msg.LogCurrent)
        Assert.IsNull(msg.LogStack)

        Using Log.Start(UniqueData)
            msg = LastMessage
            Assert.AreEqual("Start " + UniqueData, msg.Message)
            Assert.AreEqual(UniqueData, msg.LogCurrent)
            Assert.AreEqual(msg.LogCurrent, msg.LogStack)

            Log.ClearStack()
            Log.Warning("Stack cleared")
            msg = LastMessage
            Assert.IsNull(msg.LogCurrent)
            Assert.IsNull(msg.LogStack)
        End Using

        'no message generated.
        Assert.AreEqual(0, _lastMessages.Count)
        Assert.IsNull(msg.LogCurrent)
        Assert.IsNull(msg.LogStack)</code></example></member>
        <member name="P:CSharpTest.Net.Logging.EventData.LogStack">
            <summary> returns the text given to all calls to Log.Start() that has not yet been Disponsed separated by '::' </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#110" cat="Source Code">Log/Log.EventData.cs</seealso><example><para><see cref="http://csharptest.net/browse/src/Log/Test/BasicLogTest.cs#276">Log/Test/BasicLogTest.cs</see></para><code lang="C#">            Log.Write(UniqueData);
            EventData msg = LastMessage;
            Assert.IsNull(msg.LogCurrent);
            Assert.IsNull(msg.LogStack);

            using (Log.Start(UniqueData))
            {
                msg = LastMessage;
                Assert.AreEqual("Start " + UniqueData, msg.Message);
                Assert.AreEqual(UniqueData, msg.LogCurrent);
                Assert.AreEqual(msg.LogCurrent, msg.LogStack);

                Log.ClearStack();
                Log.Warning("Stack cleared");
                msg = LastMessage;
                Assert.IsNull(msg.LogCurrent);
                Assert.IsNull(msg.LogStack);
            }

            //no message generated.
            Assert.AreEqual(0, _lastMessages.Count);
            Assert.IsNull(msg.LogCurrent);
            Assert.IsNull(msg.LogStack);</code><code lang="VB.NET">        Log.Write(UniqueData)
        Dim msg As EventData = LastMessage
        Assert.IsNull(msg.LogCurrent)
        Assert.IsNull(msg.LogStack)

        Using Log.Start(UniqueData)
            msg = LastMessage
            Assert.AreEqual("Start " + UniqueData, msg.Message)
            Assert.AreEqual(UniqueData, msg.LogCurrent)
            Assert.AreEqual(msg.LogCurrent, msg.LogStack)

            Log.ClearStack()
            Log.Warning("Stack cleared")
            msg = LastMessage
            Assert.IsNull(msg.LogCurrent)
            Assert.IsNull(msg.LogStack)
        End Using

        'no message generated.
        Assert.AreEqual(0, _lastMessages.Count)
        Assert.IsNull(msg.LogCurrent)
        Assert.IsNull(msg.LogStack)</code></example></member>
        <member name="P:CSharpTest.Net.Logging.EventData.Location">
            <summary>
            The full method information: Type.Name(Args)
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#115" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.Method">
            <summary>
            The full method information: Type.Name(Args)
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#120" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.FileLocation">
            <summary>
            Returns the full message of Message + Location + Exception
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#125" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="P:CSharpTest.Net.Logging.EventData.FullMessage">
            <summary>
            Returns the full message of Message + Location + Exception
            </summary>
        <seealso cref="http://csharptest.net/browse/src/Log/Log.EventData.cs#130" cat="Source Code">Log/Log.EventData.cs</seealso></member>
        <member name="M:CSharpTest.Net.Logging.Implementation.LogUtils.Format(System.String,System.Object[])">
            <seealso cref="M:Log.AppStart(System.String,System.Object[])" cat="Used By">IDisposable Log.AppStart(String,Object[])</seealso>
            <seealso cref="M:Log.Start(System.String,System.Object[])" cat="Used By">IDisposable Log.Start(String,Object[])</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.MessageQueue.ThreadingControl.#ctor(System.String)">
            <seealso cref="M:Log.AppStart(System.String,System.Object[])" cat="Used By">IDisposable Log.AppStart(String,Object[])</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.TraceStack.#ctor(System.String)">
            <seealso cref="M:Log.Start(System.String,System.Object[])" cat="Used By">IDisposable Log.Start(String,Object[])</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.TraceStack.Clear">
            <seealso cref="M:Log.ClearStack" cat="Used By">Log.ClearStack()</seealso>
        </member>
        <member name="F:Log.e">
            <seealso cref="M:Log.Write(System.String,System.Object[])" cat="Used By">Log.Write(String,Object[])</seealso>
            <seealso cref="M:Log.Critical(System.String,System.Object[])" cat="Used By">Log.Critical(String,Object[])</seealso>
            <seealso cref="M:Log.Error(System.String,System.Object[])" cat="Used By">Log.Error(String,Object[])</seealso>
            <seealso cref="M:Log.Warning(System.String,System.Object[])" cat="Used By">Log.Warning(String,Object[])</seealso>
            <seealso cref="M:Log.Info(System.String,System.Object[])" cat="Used By">Log.Info(String,Object[])</seealso>
            <seealso cref="M:Log.Verbose(System.String,System.Object[])" cat="Used By">Log.Verbose(String,Object[])</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.MessageQueue.Push(System.Int32,CSharpTest.Net.Logging.LogLevels,System.Exception,System.String,System.Object[])">
            <seealso cref="M:Log.Write(System.String,System.Object[])" cat="Used By">Log.Write(String,Object[])</seealso>
            <seealso cref="M:Log.Critical(System.Exception)" cat="Used By">Log.Critical(Exception)</seealso>
            <seealso cref="M:Log.Critical(System.Exception,System.String,System.Object[])" cat="Used By">Log.Critical(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Critical(System.String,System.Object[])" cat="Used By">Log.Critical(String,Object[])</seealso>
            <seealso cref="M:Log.Error(System.Exception)" cat="Used By">Log.Error(Exception)</seealso>
            <seealso cref="M:Log.Error(System.Exception,System.String,System.Object[])" cat="Used By">Log.Error(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Error(System.String,System.Object[])" cat="Used By">Log.Error(String,Object[])</seealso>
            <seealso cref="M:Log.Warning(System.Exception)" cat="Used By">Log.Warning(Exception)</seealso>
            <seealso cref="M:Log.Warning(System.Exception,System.String,System.Object[])" cat="Used By">Log.Warning(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Warning(System.String,System.Object[])" cat="Used By">Log.Warning(String,Object[])</seealso>
            <seealso cref="M:Log.Info(System.Exception)" cat="Used By">Log.Info(Exception)</seealso>
            <seealso cref="M:Log.Info(System.Exception,System.String,System.Object[])" cat="Used By">Log.Info(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Info(System.String,System.Object[])" cat="Used By">Log.Info(String,Object[])</seealso>
            <seealso cref="M:Log.Verbose(System.Exception)" cat="Used By">Log.Verbose(Exception)</seealso>
            <seealso cref="M:Log.Verbose(System.Exception,System.String,System.Object[])" cat="Used By">Log.Verbose(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Verbose(System.String,System.Object[])" cat="Used By">Log.Verbose(String,Object[])</seealso>
            <seealso cref="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)" cat="Used By">LogLevels Log.Config.SetOutputLevel(LogOutputs,LogLevels)</seealso>
            <seealso cref="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)" cat="Used By">Log.Config.SetOutputFormat(LogOutputs,String)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.LogLevel">
            <seealso cref="M:Log.Critical(System.Exception)" cat="Used By">Log.Critical(Exception)</seealso>
            <seealso cref="M:Log.Critical(System.Exception,System.String,System.Object[])" cat="Used By">Log.Critical(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Critical(System.String,System.Object[])" cat="Used By">Log.Critical(String,Object[])</seealso>
            <seealso cref="M:Log.Error(System.Exception)" cat="Used By">Log.Error(Exception)</seealso>
            <seealso cref="M:Log.Error(System.Exception,System.String,System.Object[])" cat="Used By">Log.Error(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Error(System.String,System.Object[])" cat="Used By">Log.Error(String,Object[])</seealso>
            <seealso cref="M:Log.Warning(System.Exception)" cat="Used By">Log.Warning(Exception)</seealso>
            <seealso cref="M:Log.Warning(System.Exception,System.String,System.Object[])" cat="Used By">Log.Warning(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Warning(System.String,System.Object[])" cat="Used By">Log.Warning(String,Object[])</seealso>
            <seealso cref="M:Log.Info(System.Exception)" cat="Used By">Log.Info(Exception)</seealso>
            <seealso cref="M:Log.Info(System.Exception,System.String,System.Object[])" cat="Used By">Log.Info(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Info(System.String,System.Object[])" cat="Used By">Log.Info(String,Object[])</seealso>
            <seealso cref="M:Log.Verbose(System.Exception)" cat="Used By">Log.Verbose(Exception)</seealso>
            <seealso cref="M:Log.Verbose(System.Exception,System.String,System.Object[])" cat="Used By">Log.Verbose(Exception,String,Object[])</seealso>
            <seealso cref="M:Log.Verbose(System.String,System.Object[])" cat="Used By">Log.Verbose(String,Object[])</seealso>
        </member>
        <member name="F:Log.format">
            <seealso cref="M:Log.Critical(System.Exception)" cat="Used By">Log.Critical(Exception)</seealso>
            <seealso cref="M:Log.Error(System.Exception)" cat="Used By">Log.Error(Exception)</seealso>
            <seealso cref="M:Log.Warning(System.Exception)" cat="Used By">Log.Warning(Exception)</seealso>
            <seealso cref="M:Log.Info(System.Exception)" cat="Used By">Log.Info(Exception)</seealso>
            <seealso cref="M:Log.Verbose(System.Exception)" cat="Used By">Log.Verbose(Exception)</seealso>
        </member>
        <member name="F:Log.args">
            <seealso cref="M:Log.Critical(System.Exception)" cat="Used By">Log.Critical(Exception)</seealso>
            <seealso cref="M:Log.Error(System.Exception)" cat="Used By">Log.Error(Exception)</seealso>
            <seealso cref="M:Log.Warning(System.Exception)" cat="Used By">Log.Warning(Exception)</seealso>
            <seealso cref="M:Log.Info(System.Exception)" cat="Used By">Log.Info(Exception)</seealso>
            <seealso cref="M:Log.Verbose(System.Exception)" cat="Used By">Log.Verbose(Exception)</seealso>
        </member>
        <member name="M:Log.ToString">
            <seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso>
        </member>
        <member name="M:Log.Equals(System.Object)">
            <seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso>
        </member>
        <member name="M:Log.GetHashCode">
            <seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso>
        </member>
        <member name="M:Log.GetType">
            <seealso cref="http://csharptest.net/browse/src/Log/Log.cs" cat="Source Code">Log/Log.cs</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.LEVEL_ASPNET">
            <seealso cref="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)" cat="Used By">LogLevels Log.Config.SetOutputLevel(LogOutputs,LogLevels)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.LEVEL_CONSOLE">
            <seealso cref="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)" cat="Used By">LogLevels Log.Config.SetOutputLevel(LogOutputs,LogLevels)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.LEVEL_EVENTLOG">
            <seealso cref="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)" cat="Used By">LogLevels Log.Config.SetOutputLevel(LogOutputs,LogLevels)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.LEVEL_LOGFILE">
            <seealso cref="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)" cat="Used By">LogLevels Log.Config.SetOutputLevel(LogOutputs,LogLevels)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.LEVEL_TRACE">
            <seealso cref="M:Log.Config.SetOutputLevel(CSharpTest.Net.Logging.LogOutputs,CSharpTest.Net.Logging.LogLevels)" cat="Used By">LogLevels Log.Config.SetOutputLevel(LogOutputs,LogLevels)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.LogUtils.PrepareFormatString(System.String)">
            <seealso cref="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)" cat="Used By">Log.Config.SetOutputFormat(LogOutputs,String)</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.EventData.ToString(System.String)" cat="Used By">String EventData.ToString(String)</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter,System.String)" cat="Used By">EventData.Write(TextWriter,String)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FORMAT_ASPNET">
            <seealso cref="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)" cat="Used By">Log.Config.SetOutputFormat(LogOutputs,String)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FORMAT_CONSOLE">
            <seealso cref="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)" cat="Used By">Log.Config.SetOutputFormat(LogOutputs,String)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FORMAT_EVENTLOG">
            <seealso cref="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)" cat="Used By">Log.Config.SetOutputFormat(LogOutputs,String)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FORMAT_LOGFILE">
            <seealso cref="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)" cat="Used By">Log.Config.SetOutputFormat(LogOutputs,String)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FORMAT_TRACE">
            <seealso cref="M:Log.Config.SetOutputFormat(CSharpTest.Net.Logging.LogOutputs,System.String)" cat="Used By">Log.Config.SetOutputFormat(LogOutputs,String)</seealso>
        </member>
        <member name="M:Log.Config.ToString">
            <seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso>
        </member>
        <member name="M:Log.Config.Equals(System.Object)">
            <seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso>
        </member>
        <member name="M:Log.Config.GetHashCode">
            <seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso>
        </member>
        <member name="M:Log.Config.GetType">
            <seealso cref="http://csharptest.net/browse/src/Tools/CmdTool/Config.cs" cat="Source Code">Tools/CmdTool/Config.cs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.LogEventHandler.Invoke(System.Object,CSharpTest.Net.Logging.LogEventArgs)">
            <seealso cref="T:CSharpTest.Net.Logging.LogEventArgs">LogEventArgs</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.LogEventHandler.BeginInvoke(System.Object,CSharpTest.Net.Logging.LogEventArgs,System.AsyncCallback,System.Object)">
            <seealso cref="T:CSharpTest.Net.Logging.LogEventArgs">LogEventArgs</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.LogEventArgs._data">
            <seealso cref="M:CSharpTest.Net.Logging.LogEventArgs.ToArray" cat="Used By">EventData[] LogEventArgs.ToArray()</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.LogEventArgs.ToString" cat="Used By">String LogEventArgs.ToString()</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.LogEventArgs.GetEnumerator" cat="Used By">IEnumerator&lt;EventData&gt; LogEventArgs.GetEnumerator()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.InnerFormatter">
            <seealso cref="M:CSharpTest.Net.Logging.EventData.ToString" cat="Used By">String EventData.ToString()</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.EventData._data">
            <seealso cref="M:CSharpTest.Net.Logging.EventData.ToString" cat="Used By">String EventData.ToString()</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.Xml.XmlWriter)" cat="Used By">EventData.Write(XmlWriter)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FormatProvider">
            <seealso cref="M:CSharpTest.Net.Logging.EventData.ToString(System.String)" cat="Used By">String EventData.ToString(String)</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter)" cat="Used By">EventData.Write(TextWriter)</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter,System.String)" cat="Used By">EventData.Write(TextWriter,String)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.Implementation.LogUtils.LogError(System.Exception)">
            <seealso cref="M:CSharpTest.Net.Logging.EventData.ToString(System.String)" cat="Used By">String EventData.ToString(String)</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter)" cat="Used By">EventData.Write(TextWriter)</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter,System.String)" cat="Used By">EventData.Write(TextWriter,String)</seealso>
            <seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.Xml.XmlWriter)" cat="Used By">EventData.Write(XmlWriter)</seealso>
        </member>
        <member name="F:CSharpTest.Net.Logging.Implementation.Configuration.FORMAT_DEFAULT">
            <seealso cref="M:CSharpTest.Net.Logging.EventData.Write(System.IO.TextWriter)" cat="Used By">EventData.Write(TextWriter)</seealso>
        </member>
        <member name="M:CSharpTest.Net.Logging.LogEventHandler.#ctor(System.Object,System.IntPtr)">
            <example>
                <para>
                    <see cref="http://csharptest.net/browse/src/Log/Test/ThreadedLogTest.cs#50">Log/Test/ThreadedLogTest.cs</see>
                </para>
                <code lang="C#">            Log.LogWrite += new LogEventHandler(Block_LogWrite);
            try
            {
                using (Log.Start("Blocking Test"))
                {
                    //the start above should already get us in a blocked state:
                    Assert.IsTrue(_isBlocked.WaitOne(300, false));

                    //regaurdless, we should still get the first message
                    EventData msg = NextMessage;
                    Assert.AreEqual("Start Blocking Test", msg.Message);

                    //Now let's just go nuts on the logger...
                    for (int i = 0; i &lt; 100; i++)
                        Log.Write("Buffering at {0}%.", i);

                    Thread.Sleep(100);
                    Assert.AreEqual(0, _lastMessages.Count);
                    _releaseBlock.Set();
                    Thread.Sleep(100);
                    Assert.IsFalse(_isBlocked.WaitOne(0, false));

                    for (int i = 0; i &lt; 100; i++)
                        Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"));
                }
            }
            finally
            {
                Log.LogWrite -= new LogEventHandler(Block_LogWrite);
            }</code>
                <code lang="VB.NET">        Log.LogWrite += New LogEventHandler(Block_LogWrite)
        Try
            Using Log.Start("Blocking Test")
                'the start above should already get us in a blocked state:
                Assert.IsTrue(_isBlocked.WaitOne(300, False))

                'regaurdless, we should still get the first message
                Dim msg As EventData = NextMessage
                Assert.AreEqual("Start Blocking Test", msg.Message)

                'Now let's just go nuts on the logger...
                Dim i As Integer = 0
                While i &lt; 100
                    Log.Write("Buffering at {0}%.", i)
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While

                Thread.Sleep(100)
                Assert.AreEqual(0, _lastMessages.Count)
                _releaseBlock.[Set]()
                Thread.Sleep(100)
                Assert.IsFalse(_isBlocked.WaitOne(0, False))

                Dim i As Integer = 0
                While i &lt; 100
                    Assert.IsTrue(NextMessage.Message.StartsWith("Buffering at"))
                    System.Math.Max(System.Threading.Interlocked.Increment(i),i - 1)
                End While
            End Using
        Finally
            Log.LogWrite -= New LogEventHandler(Block_LogWrite)
        End Try</code>
            </example>
        </member>
    </members>
</doc>